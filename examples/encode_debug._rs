//! Debug example for the textbook encoder. It prints inputs, coefficients,
//! per-prime residues, and decode error statistics for a degree-512 setup.

use std::{error::Error, sync::Arc};

use crypto_bigint::BoxedUint;
use num_complex::Complex64;
use toy_heaan_ckks::encoding::{TextbookEncoder, TextbookEncodingParams};
use toy_heaan_ckks::rings::backends::rns::RnsBasisBuilder;

const DEGREE: usize = 512;
const SCALE_BITS: u32 = 45;
#[allow(dead_code)]
const PRIME_COUNT: usize = 3;
const DEMO_SLOTS: usize = 16;
const PRINT_COUNT: usize = 8;

fn main() -> Result<(), Box<dyn Error>> {
    println!("=== Textbook Encoder Debug (degree = {DEGREE}) ===");
    let basis = Arc::new(
        RnsBasisBuilder::new(DEGREE)
            .with_custom_primes(vec![
                1125899906846721,
                1125899911202817,
                1125899915558913,
            ])
            .build()?,
    );
    println!("Primes: {:?}", basis.primes());

    let params = TextbookEncodingParams::<DEGREE>::new(
        SCALE_BITS,
        Arc::new(basis.primes().clone()),
    )?;
    let encoder = TextbookEncoder::new(params);
    println!(
        "Scale bits: {}, Δ = {:.3e}",
        SCALE_BITS,
        encoder.params.scaling_factor()
    );

    let slots = build_demo_slots(DEMO_SLOTS);
    println!(
        "Input slots ({} values shown):",
        slots.len().min(PRINT_COUNT)
    );
    for (idx, value) in slots.iter().take(PRINT_COUNT).enumerate() {
        println!("  slot[{idx}] = {:.6} + {:.6}i", value.re, value.im);
    }

    let plaintext = encoder.encode_complex(&slots, &basis)?;
    println!(
        "Encoded plaintext: scale_bits = {}, stored slots = {}",
        plaintext.scale_bits, plaintext.slots
    );

    let mut coeff_poly = plaintext.poly.clone();
    coeff_poly.to_coeff_domain();
    let coeffs = coeff_poly.to_i64_coefficients();
    let max_coeff = coeffs.iter().map(|c| (*c as f64).abs()).fold(0.0, f64::max);

    let modulus = crt_modulus(basis.primes());
    let half = modulus.shr_vartime(1).unwrap_or_else(|| {
        BoxedUint::zero_with_precision(modulus.bits_precision())
    });
    println!(
        "Max |coeff| = {:.3e} (Q/2 ≈ {:.3e})",
        max_coeff,
        boxed_to_f64(&half)
    );

    println!(
        "First {} coefficients with per-prime residues:",
        PRINT_COUNT
    );
    for (idx, coeff) in coeffs.iter().take(PRINT_COUNT).enumerate() {
        println!("  coeff[{idx}] = {coeff}");
        for (channel_idx, &prime) in basis.primes().iter().enumerate() {
            let residue = coeff_poly.residue_at(channel_idx, idx);
            println!("    mod {prime:>6} → {residue}");
        }
    }

    let decoded = encoder.decode_complex(&plaintext)?;
    let max_error = slots
        .iter()
        .zip(decoded.iter())
        .map(|(expected, actual)| {
            let re_err = (expected.re - actual.re).abs();
            let im_err = (expected.im - actual.im).abs();
            re_err.max(im_err)
        })
        .fold(0.0, f64::max);

    println!("Decoded slots ({} values shown):", PRINT_COUNT);
    for (idx, value) in decoded.iter().take(PRINT_COUNT).enumerate() {
        println!("  decoded[{idx}] = {:.6} + {:.6}i", value.re, value.im);
    }
    println!("Max abs error across slots: {:.3e}", max_error);

    Ok(())
}

fn build_demo_slots(count: usize) -> Vec<Complex64> {
    (0..count)
        .map(|idx| {
            let t = idx as f64;
            let real = (t / count as f64) * 2.0 - 1.0; // linear ramp in [-1, 1]
            let imag = (t / 5.0).sin() * 0.05; // small sinusoidal imaginary part
            Complex64::new(real, imag)
        })
        .collect()
}

fn crt_modulus(primes: &[u64]) -> BoxedUint {
    primes.iter().fold(BoxedUint::from(1u64), |acc, &prime| {
        let prime_big = BoxedUint::from(prime);
        acc.mul(&prime_big)
    })
}

fn boxed_to_f64(value: &BoxedUint) -> f64 {
    const LIMB_SCALE: f64 = 18446744073709551616.0; // 2^64
    let mut acc = 0.0;
    let mut factor = 1.0;
    for word in value.as_words() {
        acc += (*word as f64) * factor;
        factor *= LIMB_SCALE;
    }
    acc
}
